{-# LANGUAGE FlexibleContexts, TemplateHaskell #-}
-- | Third phase of the compilation, lower into a emittable syntax.
-- The state generated by this module is also used for recompilation
-- Inside of dynamic systems.
module Compiler.Generate (compile,
  recompile,
  genSystem,
  ) where

import Data.Bits
import Data.Char (chr)
import Data.Maybe (fromJust)
import Data.Int (Int16)
import Data.List (intercalate, sort, sortOn, findIndex)
import qualified Data.Map as M
import qualified Data.Set as S
import Control.Arrow (second)
import Control.Lens hiding (noneOf)
import Control.Lens.TH
import Text.Printf

import Control.Monad.RWS.Lazy
import Control.Monad.State.Lazy
import Control.Monad.Except

import Compiler.AST
import Compiler.F
import Compiler.Typechecker

-- * Compilation stades

-- | Generate IR from Higher level representation
lowerHIR :: MonadCompile m => CompilationUnit HIR -> m (CompilationUnit IR)
lowerHIR c = do
  ir <- concat <$> mapM lowerHIR' (c ^. unitIR)
  pure (c {_unitIR = rewriteIR ir})

lowerHIR' :: MonadCompile m => HIR -> m [IR]
lowerHIR' (FunDef returnType s arg stmt) = fmap ((LabelIR s True :) . (pushAll (map fst arg) ++) . snd)
        (run stmt (fromIntegral $ length arg, arg))
 where mangle t s = s
       run :: (MonadCompile m) => [StatementR] -> HFState -> m (HFState, [IR])
       run stmt acc = execRWST (mapM_ genStmt stmt) (returnType, arg) acc
       genStmt :: MonadCompile m => StatementR -> HF m ()
       genStmt (Declaration t s e) = do
         typ <- case e of
           Just e -> pushExpr e
           Nothing -> Just t <$ tell (replicate (sizeOf t) $ InstIR $ Lit $ I 0)
         case typ of
           Just j -> if (j == t)
             then performPushType t
             else throwError $ TypeMismatch t j
           _ -> throwError $ CantTypeCheck "implicit cast on declaration" --performPushType t
         _1 += sizeOf t
         _2 %= ((t,s) :)
       genStmt (If cond t e) = do
         pushExpr cond
         ((depthThen, _), irt) <- lift . run t =<< get
         ((depthElse, _), ire) <- lift . run e =<< get
         depth <- use _1
         tell [ThenElse (irt ++ irAddrDropN (depthThen - depth))
                        (ire ++ irAddrDropN (depthElse - depth))]
       genStmt (While cond body) = do
         ((depthWhile, _), whl) <- lift . run (body ++ [RawPush Num cond]) =<< get
         depth <- use _1
         tell [WhileIR $ whl ++ irAddrDropN (depthWhile - depth)]
       genStmt (Raw e) = do
         t <- pushExpr e
         case t of
           Just t -> performDropType t
           Nothing -> throwError AmbiguousRawType
       genStmt (RawPush typ e) = do
         t <- pushExpr e
         case t of
           Just j -> unless (typ == j) $ throwError $ TypeMismatch typ j
           Nothing -> pure ()
       genStmt (Return r) = do
         case r of
           Just r  -> do
             t <- pushExpr r
             case t of
               Just j  -> unless (returnType == j) $ throwError $ TypeMismatch returnType j
               Nothing -> pure ()
           Nothing -> pure ()
         depth <- use _1
         tell $ irAddrDropN depth
         tell [InstIR Ret]
       genStmt (InlineAsm ir) = tell ir
       irAddrDropN n = concat $ replicate (fromIntegral n) [InstIR Pop, InstIR Drop]
       performPushType t = tell $ replicate (sizeOf t) (InstIR Push)
       performPopType t = tell $ replicate (sizeOf t) (InstIR Pop)
       performDropType t = tell $ replicate (sizeOf t) (InstIR Drop)
       -- Generate push instructions for some types
       pushAll :: [TypeR] -> [IR]
       pushAll t = replicate (sum $ map sizeOf t) (InstIR Push)

rewriteIR :: [IR] -> [IR]
rewriteIR [] = []
rewriteIR (InstIR Push : InstIR Pop: as) = rewriteIR as -- Push-Pop annulation
rewriteIR (InstIR Pop : InstIR Push: as) = rewriteIR as -- Pop-Push annulation
rewriteIR (InstIR Push : InstIR (Lit (I 0)) : InstIR Copy : as) = rewriteIR $ InstIR Dup : InstIR Push : as -- Reuse
rewriteIR (a:as) = a : rewriteIR as

-- | Compute the lower representation of the intermediate representation
lowerIR :: (MonadState VMState m) => CompilationUnit IR -> m (CompilationUnit LIR)
lowerIR c = do
  lir <- concat <$> mapM lowerIR' (c ^. unitIR)
  pure (c {_unitIR = rewriteLIR lir})

lowerIR' :: MonadState VMState m => IR -> m [LIR]
lowerIR' (LabelIR l b) = pure [LabelLIR l b]
lowerIR' (InstIR l) = pure [InstLIR l]
lowerIR' (RawIR l) = pure [RawLIR l]
lowerIR' (CallIR c) = do
    natNum <- uses nativeCalls (M.lookup c)
    case natNum of
        Just (n, _, _) -> pure [InstLIR $ Lit $ I n, InstLIR $ Nat]
        Nothing -> pure [InstLIR $ Lit $ P c, InstLIR Call]
lowerIR' (ThenElse t e) = do
  symThen <- genSymbol
  symEnd <- genSymbol
  elseCode <- concat <$> mapM lowerIR' e
  thenCode <- concat <$> mapM lowerIR' t
  pure $ [InstLIR $ Lit $ P symThen, InstLIR Jnz] ++ elseCode
      ++ [InstLIR $ Lit $ P symEnd, InstLIR Jump, LabelLIR symThen False]
      ++ thenCode ++ [LabelLIR symEnd False]
lowerIR' (WhileIR w) = do
  loop <- genSymbol
  body <- concat <$> mapM lowerIR' w
  pure $ [LabelLIR loop False] ++ body ++ [InstLIR $ Lit $ P loop, InstLIR Jnz]

-- | Pure rewrite rules for LIR
rewriteLIR :: [LIR] -> [LIR]
rewriteLIR = packLIR . filter (`notElem` [InstLIR Nop])
  where packLIR :: [LIR] -> [LIR]
        packLIR [] = []
        packLIR ((InstLIR x):(InstLIR y):(InstLIR z): as)
          | packable x && packable y = PackedLIR x y z : packLIR as
        packLIR ((InstLIR x):(InstLIR y): as)
          | packable x = PackedLIR x y Nop : packLIR as
        packLIR (a:as) = a : packLIR as

-- * Emission

-- | Emit the relative bytecode for an instruction
emit :: MonadCompile m => CompilationUnit LIR -> m (CompilationUnit Prim)
emit c = do
  (length, prim) <- execRWST (mapM_ emit' (c ^. unitIR)) () 0
  pure $ c { _unitIR = prim }
  where -- emit' :: LIR -> RWST () [Prim] Int16 m ()
        emit' (LabelLIR l b) = do
          len <- get
          let key = (c^.unitName, l)
          present <- lift $ uses localSymbols (M.member key)
          if present
            then throwError $ DuplicateSymbol key
            else lift $ do
                localSymbols %= (M.insert key len)
                when b $ symbolTable %= (S.insert key)
        emit' (InstLIR i) = write (I $ tag i) >> seInst i
        emit' (PackedLIR x y z) = do
          write $ I $ (tag z `shift` 10) .|. (tag y `shift` 5) .|. tag x
          seInst x
          seInst y
          seInst z
        emit' (RawLIR s) = write $ I s
        seInst (Lit prim) = write prim
        seInst _ = pure ()
        write p = do
          tell [p]
          id += 1

-- | Resolve all primitive into machine words
resolve :: MonadCompile m => CompilationUnit Prim -> m (CompilationUnit Int16)
resolve c = do
     source <- mapM resolve' $ c ^. unitIR
     pure $ c { _unitIR = source }
  where resolve' (I i) = pure i
        resolve' (P s) = do
          map <- use localSymbols
          let look = (c^.unitName,s)
          case look `M.lookup` map of
            Just sym -> pure sym
            Nothing -> throwError $ LinkError look

-- | Generate the c file content for the compilation unit
genSystemMap :: CompilationUnit Int16 -> F ()
genSystemMap c = do
    -- Storage type
    telln $ "#define " ++ name ++ "_prop " ++
      if c ^. unitDynamic then "static" else "const"
    -- Source code
    telln $ "#define " ++ name ++ "_code {" ++ intercalate ", " (map fmtInt16 (c^.unitIR)) ++ "}"
    -- Symbols index
    st <- uses symbolTable (map (second snd) . filter (\(_,(s,_)) -> s == name) . zip [0..] . S.toAscList)
    forM_ st $ \(i, sym) -> telln $ "#define " ++ name ++ "_sym_" ++ sym ++ " " ++ show i
    pure ()
  where name = c ^. unitName
        fmtInt16 i = printf "%i" i
-- * Compiler evaluation

-- | Default compiler sequence
compile :: AST -> Either Err (VMState, String)
compile ast = compileAST ast genSystemMap cont
  where cont = do
          m <- use localSymbols
          ai <- uses symbolTable ((++"}") . ('{':) . intercalate ", " . map (show . (m M.!)) . S.toAscList)
          let it = (++"}") . ('{':) . intercalate ", " . map (("(CELL*)" ++) . (++ "_source")) . sort . map (view unitName) $ ast^.comps
          telln $ "#define defineSymbolTable() CELL symbolTable[] = " ++ ai
          telln $ "#define defineImageTable() CELL* imageTable[] = " ++ it
          
-- | Default recompiler sequence
recompile :: System -> AST -> Either Err (VMState, [FIR])
recompile _ (AST (a:_) _) = Left (CantDefSymbol $ _natName a)
recompile system ast@(AST [] [c]) = recompileAST system ast gen $ pure ()
  where gen c = do
          sys <- ask
          case M.lookup (c^.unitName) (sys^.imageTable) of
            Nothing -> throwError $ NewUnit $ c^.unitName
            Just loc -> tell [Flash loc (c^.unitIR)]
recompile _ _ = Left (CantDefSymbol "VOID")

-- | Prepare for recompilation
genSystem :: AST -> VMState -> System
genSystem a s = System (M.fromList $ flip zip [0..] . sort $ map (view unitName) (a^.comps)) (s^.localSymbols) (s^.nativeCalls) (s^.symbolTable)

genInlines :: [NativeSrc] -> F ()
genInlines ins = do
    telln $ "void nativeHook(vm_t* vm) { switch (vmPop(vm)) { "
    flip runStateT (1::Int16) $ forM_ ins $ \nat -> case nat of
      -- NativeSrc name ([], ret) (Left var) -> do
      --   ix <- get
      --   telln $ "case " ++ show ix ++ ": " ++ intercalate " " (lines code ++ [, "break;"]) ++ " \\"
      --   telln $ "case " ++ show (ix+1) ++ ": " ++ intercalate " " (lines code ++ ["break;"]) ++ " \\"
      --   modify ix (+2)
      --   nativeCalls %= (M.insert (name) ix)
      NativeSrc name ([], typ) (Left "") -> -- Automatically make natives __getter__<name> and __setter__<name> and recursively for supported types
        genGetSet typ name
      NativeSrc name (args, returnType) (Right code) -> do
         ix <- get
         lift $ telln $ "case " ++ show ix ++ ": " ++ (code ++ " break;")
         modify succ
         lift $ nativeCalls %= (M.insert name (ix, args, returnType))
    telln "} }"
 where
  -- TODO Warn when impossible to create getter/setter
  genGetSet Num name = do
    genGetGeneric Num name "vmLit"
    genSetGeneric Num name "vmPop"
  genGetSet Num32 name = do
    genGetGeneric Num32 name "vmLit32"
    genSetGeneric Num32 name "vmPop32"
  genGetSet Float32 name = do
    genGetGeneric Float32 name "vmLitFloat"
    genSetGeneric Float32 name "vmPopFloat"
  genGetSet (StructType st) name = do
    forM_ st $ \(ns, typ) -> genGetSet typ (name ++ "." ++ ns)
  genGetSet (UnionType ut) name = do
    forM_ ut $ \(ns, typ) -> genGetSet typ (name ++ "." ++ ns)
  genGetSet t n = throwError $ InvalidNativeVar t n
  genGetGeneric t name lit = do
    ix <- get
    lift $ telln $ "case " ++ show ix ++ ": " ++ lit ++ "(vm, " ++ name ++ "); break;"
    modify succ
    lift $ nativeCalls %= (M.insert ("__get__" ++ name) (ix, [], t))
  genSetGeneric t name lit = do
    ix <- get
    lift $ telln $ "case " ++ show ix ++ ": " ++ name ++ " = " ++ lit ++ "(vm); break;"
    modify succ
    lift $ nativeCalls %= (M.insert ("__set__" ++ name) (ix, [t], Void))
-- * Helpers

recompileAST :: System -- ^ The System for which to compile
             -> AST -- ^ The AST currently compiled for
             -> (CompilationUnit Int16 -> R ()) -- ^ The flash action
             -> R () -- ^ Continuation
             -> Either Err (VMState, [FIR])
recompileAST sys (AST inls cus) gen cont = runExcept $ execRWST compile' sys (VMState 0 M.empty M.empty S.empty)
  where compile' = do
          ask >>= \sys -> nativeCalls .= (sys ^. lastNativeCalls)
          forM_ cus $ lowerHIR >=> lowerIR >=> emit >=> resolve >=> gen
          cont

compileAST :: AST -- ^ The ast currently compiled for
           -> (CompilationUnit Int16 -> F ()) -- ^ The generator
           -> F a -- ^ Continuation
           -> Either Err (VMState, String)
compileAST (AST inls cus) gen cont = runExcept $ execRWST compile' () (VMState 0 M.empty M.empty S.empty)
  where compile' = do
          genInlines inls
          forM_ cus $ lowerHIR >=> lowerIR >=> emit >=> resolve >=> gen
          cont

genSymbol :: MonadState VMState m => m String
genSymbol = do
  s <- use intGen
  intGen += 1
  pure $ show s

telln = tell . (++"\n")
tellI :: MonadWriter String m => Int16 -> m ()
tellI i = tell [chr (fromIntegral $ i .&. 0xFF), chr (fromIntegral $ i `shift` (-8))]
tellS :: MonadWriter String m => Int16 -> m ()
tellS = tell . (++" ") . show
